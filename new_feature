#!/usr/bin/env python
# -*- encoding: utf-8 -*-
"""
@File    :   new_feature.py
@Contact :   zhumeng@bupt.edu.cn
@License :   (C)Copyright 2019 zhumeng

@Modify Time      @Author    @Version    @Desciption
------------      -------    --------    -----------
2019/12/9 20:57      xm         1.0          None
"""
import time
import numpy as np
import pandas as pd
import os
from preProcess import *
from collections import Counter

'''
DEFINITION: 
PacketToProxy: 1
PacketFromProxy: 0
'''
rootPath = os.path.abspath(os.path.dirname(__file__)).split('application')[0]  # /home/byr/xiaomeng/
proxy_port = tuple(('7a', '31'))


def seq_of_pck(data, lists, sess_size=16):
    """
    Function: according the ip to obtain the sequence of packet in a session
    :param data: a Dict contain all DataFrame of each Application. s.t. data={'app1':app1_df, ...}
    :param lists: lists[Chrome] = {port1:[1,2,10,33,....], port2:[3,4,5,6,....],...}
    :return: sorted packets in session in hex
    """
    # slice 16th~175th, column index keep same
    for aName, df in data.items():
        s = np.array([np.arange(0, 20)])
        for port, l in lists.get(aName).items():
            if port == proxy_port:
                continue
            else:
                seq = [1 if (tuple(df.iloc[i, 36:38].values) == proxy_port) else 0 for i in l[0:sess_size]]
                slen = [int(x) for x in str(format(len(seq) - 1, 'b')).rjust(4, '0')]

                if len(seq) != 16:
                    seq = seq + [0] * (16 - len(seq))
                s = np.concatenate((s, np.array([seq + slen])), axis=0)
        data[aName] = pd.DataFrame(s[1:], columns=s[0])
        print(aName + ' ... [Done]')
    return data


def byte_distribution_of_sess(data, k=21):
    """
    Function: according the ip to obtain the sequence of packet in a session
    :param data: a Dict contain all DataFrame of each Application. s.t. data={'app1':app1_df, ...}
    :param lists: lists[Chrome] = {port1:[1,2,10,33,....], port2:[3,4,5,6,....],...}
    :return: sorted packets in session in hex
    """
    # slice 16th~175th, column index keep same
    for aName, df in data.items():
        top_ks = np.array([np.arange(0, k)])
        for i in range(0, len(df)):
            top_k = Counter(df.iloc[i].tolist()).most_common(k)
            top_ks = np.concatenate((top_ks, np.array([[rst[0] for rst in top_k]])), axis=0)
        data[aName] = pd.DataFrame(top_ks[1:], columns=top_ks[0]).iloc[:, 1:]
        print(aName + ' ... [Done]')
        print(data[aName])
    return data


if __name__ == "__main__":
    pd.set_option('mode.chained_assignment', None)
    start = time.time()
    print("--------------------START--------------------")
    print("1. Read from txt:")
    pData = read_from_txt()
    print('---------------------------------------------')
    print("2. Merge session:")
    pList = session_merge(pData)
    print('---------------------------------------------')
    # Add the Sequence of Packet info
    # fun(pData, pList)
    # print('---------------------------------------------')
    print("3. Format session:")
    sData = rawdata_format(pData, pList)
    print('---------------------------------------------')
    print("4. Decimal  conversion:")
    dData = hex_convert_dec(sData)
    print('---------------------------------------------')
    # new feature1: sequence of packet direction and length
    # spdlData = seq_of_pck(pData, pList)
    # new feature1: sequence of packet direction and length
    bdData = byte_distribution_of_sess(dData)
